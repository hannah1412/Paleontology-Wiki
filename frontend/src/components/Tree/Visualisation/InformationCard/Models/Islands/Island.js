/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: clementvalla1 (https://sketchfab.com/clementvalla1)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/hunter-island-08-a06e3667a90144f398e8b66fa5492d75
Title: Hunter Island 08
*/

import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei"
import islandScene from '../../../../../../../public/3d/hunterIsland.glb'
import { useFrame, useThree } from "@react-three/fiber";

const Island = ({isRotating, setIsRotating, ...props}) => {
  const { nodes, materials } = useGLTF(islandScene);
  const islandRef = useRef();
  const { gl, viewport } = useThree();

  const lastHorizontalPosition = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);

    const clientX = e.touches ?
                    e.touches[0].clientX : e.clientX;
    
    lastHorizontalPosition.current = clientX;
  }

  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);

  }

  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if(isRotating){
        const clientX = e.touches ?
                        e.touches[0].clientX : e.clientX;
        
        const delta = (clientX - lastHorizontalPosition.current) / viewport.width;

        // update the island rotation based on the mouse
        islandRef.current.rotation.y += delta * 0.007 * Math.PI;
    
        lastHorizontalPosition.current = clientX;
    
        rotationSpeed.current = delta * 0.01 * Math.PI;
    }
  }

  // Accessibility: using keyboard control 
  const hanleKeyboardDown = (e) => {
    if(e.key === 'ArrowLeft'){
      if(!isRotating) setIsRotating(true); 
      islandRef.current.rotation.y -= 0.1 * Math.PI;
    }else if(e.key === 'ArrowRight'){
      if(!isRotating) setIsRotating(true);
      islandRef.current.rotation.y += 0.1 * Math.PI;
    }
  }

  const handleKeyboardUp = (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
      setIsRotating(false);
    }
  }

  useFrame(() => {
    if(!isRotating){
        rotationSpeed.current *= dampingFactor;

        if(Math.abs(rotationSpeed.current) < 0.001){
            rotationSpeed.current = 0;
        }

        // slow the speed down 
        islandRef.current.rotation.y += rotationSpeed.current;
    }else{
        const rotation = islandRef.current.rotation.y;
    }
  })

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("pointerup", handlePointerUp);
    document.addEventListener("keydown", hanleKeyboardDown);
    document.addEventListener("keyup", handleKeyboardUp);
    return () => {
        canvas.removeEventListener("pointerdown", handlePointerDown);
        canvas.removeEventListener("pointermove", handlePointerMove);
        canvas.removeEventListener("pointerup", handlePointerUp);
        document.removeEventListener("keydown", hanleKeyboardDown);
        document.removeEventListener("keyup", handleKeyboardUp);
    }

  }, [gl, handlePointerMove, handlePointerDown, handlePointerUp])
  return (
    <group ref={islandRef} {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Object_2.geometry}
        material={materials.model}
        rotation={[-Math.PI /2, 0, 0]}
      />
    </group>
  );
}

export default Island;
